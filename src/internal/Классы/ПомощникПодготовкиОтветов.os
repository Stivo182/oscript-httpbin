// BSLLS:ExportVariables-off

#Использовать 1connector
#Использовать compressor

Перем ТекстRobots Экспорт;          // Строка - Содержимое файла robots.txt
Перем ASCII_Deny Экспорт;           // Строка - ASCII-арт для страницы отказа доступа
Перем ASCII_Teapot;                 // Строка - ASCII-арт чайника для HTTP 418
Перем АдресРедиректа;               // Строка - URL для редиректов (по умолчанию)
Перем ПоддерживаемыеМедиаТипы;      // Массив из Строка - Список поддерживаемых MIME-типов

Перем НастройкиВебСервера;          // Настройки - Настройки веб-сервера (см. winow)
Перем Парсеры;                      // Парсеры - Утилиты парсинга (см. winow)
Перем ЭтоНативныйВебСервер;         // Булево - Признак использования нативного веб-сервера

#Область ПрограммныйИнтерфейс

// Формирует JSON-ответ с опциональным сжатием.
//
// Параметры:
//   Ответ          - Ответ - Объект ответа для заполнения (см. winow)
//   Данные         - Соответствие, Структура - Данные для сериализации в JSON
//   АлгоритмСжатия - Строка, Неопределено - Алгоритм сжатия тела ответа (gzip, deflate, brotli, zstd)
//
Процедура ЗаполнитьОтветJson(Ответ, Данные, АлгоритмСжатия = Неопределено) Экспорт

	Ответ.УстановитьТипКонтента("json");
	
	ТекстJson = ВJson(Данные);
	Компрессор = Неопределено;

	Если АлгоритмСжатия = "gzip" Тогда

		Компрессор = Новый GZipКомпрессор();
		ЗаголовокСжатия = "gzip";

	ИначеЕсли АлгоритмСжатия = "deflate" Тогда

		Компрессор = Новый DeflateКомпрессор();
		ЗаголовокСжатия = "deflate";

	ИначеЕсли АлгоритмСжатия = "brotli" Тогда

		Компрессор = Новый BrotliКомпрессор();
		ЗаголовокСжатия = "br";

	ИначеЕсли АлгоритмСжатия = "zstd" Тогда

		Компрессор = Новый ZStdКомпрессор();
		ЗаголовокСжатия = "zstd";

	КонецЕсли;

	Если Не Компрессор = Неопределено Тогда
		ДвоичныеДанные = ПолучитьДвоичныеДанныеИзСтроки(ТекстJson);
		Ответ.Заголовки["Content-Encoding"] = ЗаголовокСжатия;
		Ответ.ТелоДвоичныеДанные = Компрессор.Упаковать(ДвоичныеДанные);
	Иначе
		Ответ.ТелоТекст = ТекстJson;
	КонецЕсли;

КонецПроцедуры

// Заполняет ответ стандартным содержимым для указанного HTTP-статуса.
//
// Параметры:
//   Ответ        - Ответ - Объект ответа для заполнения (см. winow)
//   КодСостояния - Число - Код HTTP-статуса
//
Процедура ЗаполнитьОтветПоСостоянию(Ответ, КодСостояния) Экспорт
	
	Ответ.УстановитьСостояние(КодСостояния);

	Если КодСостояния >= КодыСостоянияHTTP.ПеремещеноНавсегда_301 
		И КодСостояния <= КодыСостоянияHTTP.ВременноеПеренаправление_307
		И Не КодСостояния = КодыСостоянияHTTP.НеИзменялось_304 Тогда

		Ответ.Заголовки["Location"] = АдресРедиректа;

	ИначеЕсли КодСостояния = КодыСостоянияHTTP.НеАвторизован_401 Тогда

		Ответ.Заголовки["WWW-Authenticate"] = "Basic realm=""Fake Realm""";

	ИначеЕсли КодСостояния = КодыСостоянияHTTP.НеобходимаОплата_402 Тогда

		Ответ.ТелоТекст = "Fuck you, pay me!";
		Ответ.Заголовки["x-more-info"] = "http://vimeo.com/22053820";

	ИначеЕсли КодСостояния = КодыСостоянияHTTP.Неприемлемо_406 Тогда

		Данные = Новый Структура();
		Данные.Вставить("message", "Client did not request a supported media type.");
		Данные.Вставить("accept", ПоддерживаемыеМедиаТипы);

		ЗаполнитьОтветJson(Ответ, Данные);

	ИначеЕсли КодСостояния = КодыСостоянияHTTP.НеобходимаАутентификацияПрокси_407 Тогда

		Ответ.Заголовки["Proxy-Authenticate"] = "Basic realm=""Fake Realm""";

	ИначеЕсли КодСостояния = 418 Тогда

		Ответ.ТелоТекст = ASCII_Teapot;
		Ответ.СостояниеТекст = "I'm a teapot";
		Ответ.Заголовки["x-more-info"] = "http://tools.ietf.org/html/rfc2324";
		Ответ.Заголовки.Удалить("Content-Type");

	КонецЕсли;

КонецПроцедуры

// Извлекает и структурирует данные из входящего HTTP-запроса.
// Возвращает только указанные ключи из полного набора данных запроса.
//
// Параметры:
//   Ключи       - Строка - Имена возвращаемых полей через запятую.
//                          Доступные поля: url, method, args, headers, origin, json,
//                          data, form, files, gzipped, deflated, brotli, zstd
//   Запрос      - ВходящийЗапрос - Объект входящего HTTP-запроса (см. winow)
//   ДанныеФормы - ДанныеСоставнойФормы, Неопределено - Данные multipart/form-data (см. winow)
//
// Возвращаемое значение:
//   Структура - Структура с запрошенными полями:
//     * url - Строка - Полный URL запроса
//     * method - Строка - HTTP-метод (GET, POST, PUT и т.д.)
//     * args - Соответствие - Параметры строки запроса
//     * headers - Соответствие - Заголовки запроса
//     * origin - Строка - IP-адрес клиента
//     * json - Соответствие, null - Распарсенное JSON-тело (если Content-Type: application/json)
//     * data - Строка - Сырое тело запроса (если не form-data)
//     * form - Соответствие - Данные формы (application/x-www-form-urlencoded или multipart)
//     * files - Соответствие - Загруженные файлы из multipart/form-data
//     * gzipped - Булево - Всегда Истина (поддержка gzip)
//     * deflated - Булево - Всегда Истина (поддержка deflate)
//     * brotli - Булево - Всегда Истина (поддержка brotli)
//     * zstd - Булево - Всегда Истина (поддержка zstd)
//
Функция ПолучитьДанныеЗапроса(Ключи, Запрос, ДанныеФормы = Неопределено) Экспорт
	
	ДанныеФормы = РазделитьДанныеФормы(ДанныеФормы);
	ТелоЗапросаОбъект = Запрос.ТелоЗапросаОбъект(Тип("Соответствие"));
	Данные = "";

	ТипКонтента = НРег(ЗначениеЗаголовка(Запрос.Заголовки, "Content-Type"));
	Если СтрНайти(ТипКонтента, "application/x-www-form-urlencoded") Тогда
		ДанныеФормы.Данные = Парсеры.ПараметрыИзТекста(Запрос.Тело);
	ИначеЕсли Не ЗначениеЗаполнено(ДанныеФормы.Данные) И Не ЗначениеЗаполнено(ДанныеФормы.Файлы) Тогда
		Данные = Запрос.Тело;
	КонецЕсли;

	ДанныеЗапроса = Новый Структура();
	ДанныеЗапроса.Вставить("url", URL(Запрос.ПолныйПуть));
	ДанныеЗапроса.Вставить("method", Запрос.Метод);
	ДанныеЗапроса.Вставить("args", Запрос.ПараметрыИменные);
	ДанныеЗапроса.Вставить("headers", ЗаголовкиДляJson(Запрос.Заголовки));
	ДанныеЗапроса.Вставить("origin", IPАдресУдаленногоУзла(Запрос));
	ДанныеЗапроса.Вставить("json", ?(Не ТелоЗапросаОбъект = Неопределено, ТелоЗапросаОбъект, null));
	ДанныеЗапроса.Вставить("data", Данные);
	ДанныеЗапроса.Вставить("form", ДанныеФормы.Данные);
	ДанныеЗапроса.Вставить("files", ДанныеФормы.Файлы);
	ДанныеЗапроса.Вставить("gzipped", Истина);
	ДанныеЗапроса.Вставить("deflated", Истина);
	ДанныеЗапроса.Вставить("brotli", Истина);
	ДанныеЗапроса.Вставить("zstd", Истина);

	Результат = СкопироватьСтруктуру(ДанныеЗапроса, Ключи);

	Возврат Результат;

КонецФункции

// Извлекает данные аутентификации из заголовка Authorization.
// Поддерживает схемы Basic и Bearer.
//
// Параметры:
//   Запрос - ВходящийЗапрос - Объект входящего HTTP-запроса (см. winow)
//
// Возвращаемое значение:
//   Структура - Данные аутентификации:
//     Общие поля:
//       * Тип - Строка - Схема аутентификации ("basic", "bearer" или пустая строка)
//     
//     Для Basic-аутентификации (Тип = "basic"):
//       * ИмяПользователя - Строка, Неопределено - Имя пользователя
//       * Пароль - Строка, Неопределено - Пароль
//     
//     Для Bearer-токена (Тип = "bearer"):
//       * Токен - Строка - Значение токена
//
Функция ДанныеАутентификации(Запрос) Экспорт

	Данные = Новый Структура("Тип", "");

	Заголовок = ЗначениеЗаголовка(Запрос.Заголовки, "Authorization");
	Если ПустаяСтрока(Заголовок) Тогда
		Возврат Данные;
	КонецЕсли;

	РазделеннаяСтрока = РазделитьСтроку(Заголовок, " ");

	ТипАутентификации = НРег(РазделеннаяСтрока.Лево);
	Данные.Тип = ТипАутентификации;

	Значение = РазделеннаяСтрока.Право;

	Если ТипАутентификации = "basic" Тогда

		Данные.Вставить("ИмяПользователя");
		Данные.Вставить("Пароль");

		Попытка
			ПользовательИПароль = ПолучитьСтрокуИзДвоичныхДанных(Base64Значение(Значение));
			ПользовательИПароль = РазделитьСтроку(ПользовательИПароль, ":");
			
			Данные.ИмяПользователя = ПользовательИПароль.Лево;
			Данные.Пароль = ПользовательИПароль.Право;	
		Исключение	
			Данные.ИмяПользователя = Неопределено;
			Данные.Пароль = Неопределено;			
		КонецПопытки;

	ИначеЕсли ТипАутентификации = "bearer" Тогда

		Данные.Вставить("Токен", Значение);

	КонецЕсли;

	Возврат Данные;

КонецФункции

// Извлекает значение HTTP-заголовка по имени (регистронезависимый поиск).
//
// Параметры:
//   Заголовки - Соответствие, СловарьЗаголовков - Коллекция заголовков
//   Имя - Строка - Имя заголовка для поиска (регистр не важен)
//
// Возвращаемое значение:
//   Строка, Соответствие, Неопределено
//
Функция ЗначениеЗаголовка(Заголовки, Знач Имя) Экспорт

	Имя = НРег(Имя);

	Для Каждого Заголовок Из Заголовки Цикл
		Если НРег(Заголовок.Ключ) = Имя Тогда
			Если ТипЗнч(Заголовок.Значение) = Тип("Строка") 
				Или ТипЗнч(Заголовок.Значение) = Тип("Соответствие") Тогда
				Возврат Заголовок.Значение;
			ИначеЕсли Заголовок.Значение.Количество() Тогда
				Возврат Заголовок.Значение[0];
			Иначе
				Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

КонецФункции

// Парсит многозначный HTTP-заголовок (например, If-Match, If-None-Match).
// Обрабатывает значения с кавычками и опциональным префиксом W/ (weak ETag).
//
// Параметры:
//   Значение - Строка - Значение заголовка с несколькими значениями через запятую
//
// Возвращаемое значение:
//   Массив из Строка - Массив извлечённых значений
//
Функция РаспаристьМногозначныйЗаголовок(Значение) Экспорт
	
	Результат = Новый Массив();

	РегулярноеВыражение = Новый РегулярноеВыражение("\s*(W\/)?\""?([^""]*)\""?\s*");
	Подстроки = СтрРазделить(Значение, ",");

	Для Каждого Подстрока Из Подстроки Цикл
		КоллекцияСовпадений = РегулярноеВыражение.НайтиСовпадения(Подстрока);

		Для Каждого Совпадение Из КоллекцияСовпадений Цикл
			НайденноеЗначение = Совпадение.Группы[2].Значение;
			Если ЗначениеЗаполнено(НайденноеЗначение) Тогда
				Результат.Добавить(НайденноеЗначение);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

	Возврат Результат;

КонецФункции

// Формирует полный URL-адрес сервиса с опциональным путем к ресурсу.
//
// Параметры:
//   АдресРесурса - Строка - Путь к ресурсу (например, "/get"). 
//                           Слэш в начале необязателен.
//
// Возвращаемое значение:
//   Строка - Полный URL
//
Функция URL(Знач АдресРесурса = "") Экспорт

	СтандартныйПорт = 80;

	Если Лев(АдресРесурса, 1) <> "/" Тогда
		АдресРесурса = "/" + АдресРесурса;
	КонецЕсли;

	Возврат СтрШаблон(
		"http://%1%2%3",
		НастройкиВебСервера.ИмяХоста,
		?(НастройкиВебСервера.Порт = СтандартныйПорт, "", ":" + Формат(НастройкиВебСервера.Порт, "ЧГ=")),
		АдресРесурса
	);

КонецФункции

// Форматирует дату в формат RFC 1123 для использования в HTTP-заголовках.
// Соответствует спецификации HTTP/1.1 (RFC 2616, раздел 3.3.1).
//
// Параметры:
//   Дата - Дата, Неопределено - Дата для форматирования
//
// Возвращаемое значение:
//   Строка - Дата в формате "Day, DD Mon YYYY HH:MM:SS GMT"
//
Функция ДатаВФорматеHTTP(Дата) Экспорт

	Возврат Формат(Дата, "Л=en; ДФ='ддд, дд МММ гггг ЧЧ:мм:сс ''GMT'''");

КонецФункции

// Безопасно преобразует строку в число.
//
// Параметры:
//   Значение - Строка - Строковое представление числа
//
// Возвращаемое значение:
//   Число - Преобразованное число или 0, если преобразование невозможно
//
Функция ВЧисло(Значение) Экспорт
	Возврат Новый ОписаниеТипов("Число").ПривестиЗначение(Значение);
КонецФункции

// Копирует все элементы из исходного соответствия в приемник.
// Существующие ключи в приемнике будут перезаписаны значениями из источника.
//
// Параметры:
//   Приемник - Соответствие - Соответствие, в которое копируются данные
//   Источник - Соответствие - Соответствие-источник данных
//
Процедура ДополнитьСоответствие(Приемник, Источник) Экспорт

	Для Каждого Элемент Из Источник Цикл
		Приемник.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Выбирает случайный элемент из взвешенного списка.
// Вероятность выбора элемента пропорциональна его весу.
// Использует бинарный поиск для эффективного выбора.
//
// Параметры:
//   Список - Массив из Структура - Взвешенный список элементов:
//     * Значение - Произвольный - Значение элемента для возврата
//     * Вес      - Число - Вес элемента (чем больше, тем выше вероятность выбора)
//
// Возвращаемое значение:
//   Произвольный - Случайно выбранное значение с учётом весов
//
Функция ВыбратьСлучайныйЭлементСУчетомВеса(Список) Экспорт
	
	ОбщийВес = 0;
	НакопленныеВеса = Новый Массив();
	Для Каждого Элемент Из Список Цикл
		ОбщийВес = ОбщийВес + Элемент.Вес;
		НакопленныеВеса.Добавить(ОбщийВес);
	КонецЦикла;

	ГСЧ = Новый ГенераторСлучайныхЧисел();
	СлучайноеЧисло = ГСЧ.СлучайноеЧисло(0, ОбщийВес);

	НижняяГраница = 0;
	ВерхняяГраница = Список.Количество();
	Пока НижняяГраница < ВерхняяГраница Цикл
		Середина = Цел((НижняяГраница + ВерхняяГраница) / 2);
		Если СлучайноеЧисло < НакопленныеВеса[Середина] Тогда
			ВерхняяГраница = Середина;
		Иначе
			НижняяГраница = Середина + 1;
		КонецЕсли;
	КонецЦикла;

	Возврат Список[НижняяГраница].Значение;

КонецФункции

// Разделяет строку на две части по первому вхождению разделителя.
//
// Параметры:
//   Строка      - Строка - Исходная строка для разделения
//   Разделитель - Строка - Строка-разделитель
//
// Возвращаемое значение:
//   Структура - Части строки:
//     * Лево - Строка - Часть до разделителя
//     * Право - Строка - Часть после разделителя
Функция РазделитьСтроку(Строка, Разделитель) Экспорт

	Результат = Новый Структура("Лево, Право", "", "");
	ПозицияРазделителя = СтрНайти(Строка, Разделитель);

	Если ПозицияРазделителя = 0 Тогда
		Результат.Лево = Строка;
	Иначе
		Результат.Лево = Лев(Строка, ПозицияРазделителя - 1);
		Результат.Право = Сред(Строка, ПозицияРазделителя + СтрДлина(Разделитель));
	КонецЕсли;

	Возврат Результат;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

&Желудь
Процедура ПриСозданииОбъекта(
	&Пластилин("Настройки") Настройки,
	&Пластилин("Парсеры") _Парсеры,
	&Пластилин("ВебСервер") _ВебСервер)

	НастройкиВебСервера = Настройки;
	Парсеры = _Парсеры;
	ЭтоНативныйВебСервер = ТипЗнч(_ВебСервер) = Тип("НативныйВебСервер");
	
	ЗаполнитьПоддерживаемыеМедиаТипы();
	АдресРедиректа = "/redirect/1";
	
	ТекстRobots = "User-agent: *
	|Disallow: /deny";
	
	ASCII_Deny = "
	|          .-''''''-.
	|        .' _      _ '.
	|       /   O      O   \
	|      :                :
	|      |                |
	|      :       __       :
	|       \  .-""`  `""-.  /
	|        '.          .'
	|          '-......-'
	|     YOU SHOULDN'T BE HERE";

	ASCII_Teapot = "
	|    -=[ teapot ]=-
	|
	|       _...._
	|     .'  _ _ `.
	|    | .""` ^ `"". _,
	|    \_;`""---""`|//
	|      |       ;/
	|      \_     _/
	|        `""""""`";

КонецПроцедуры

// Извлекает реальный IP-адрес клиента с учётом прокси-серверов.
// Сначала проверяет заголовок X-Forwarded-For, затем использует прямой адрес.
// Удаляет IPv6-префикс ::ffff: для IPv4-адресов.
//
// Параметры:
//   Запрос - ВходящийЗапрос - Объект входящего HTTP-запроса (см. winow)
//
// Возвращаемое значение:
//   Строка - IP-адрес клиента (IPv4 или IPv6)
//
Функция IPАдресУдаленногоУзла(Запрос)

	Адрес = ЗначениеЗаголовка(Запрос.Заголовки, "X-Forwarded-For");
	Если Не ЗначениеЗаполнено(Адрес) Тогда
		Адрес = Запрос.АдресУдаленногоУзла;
	КонецЕсли;

	Подстрока = "::ffff:"; // BSLLS:UsingHardcodeNetworkAddress-off
	Если СтрНачинаетсяС(Адрес, Подстрока) Тогда
		Адрес = Сред(Адрес, СтрДлина(Подстрока) + 1);
	КонецЕсли;

	Возврат Адрес;

КонецФункции

// Парсит данные multipart/form-data и разделяет их на поля формы и файлы.
//
// Параметры:
//   ДанныеФормы - ДанныеСоставнойФормы, Неопределено - Данные составной формы
//
// Возвращаемое значение:
//   Структура:
//     * Данные - Соответствие - Текстовые поля формы
//     * Файлы - Соответствие - Загруженные файлы
//
Функция РазделитьДанныеФормы(ДанныеФормы)

	Результат = Новый Структура();
	Результат.Вставить("Данные", Новый Соответствие());
	Результат.Вставить("Файлы", Новый Соответствие());

	Если ДанныеФормы = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;

	Для Индекс = 0 По ДанныеФормы.Количество() - 1 Цикл

		Строка = ДанныеФормы.ПолучитьПоИндексу(Индекс);

		Если ЭтоНативныйВебСервер Тогда

			МетаданныеКонтента = Строка.Метаданные;
			
			Имя = МетаданныеКонтента["name"];
			Если Не Имя = Неопределено Тогда
				Имя = Имя["name"];
			КонецЕсли;

			ИмяФайла = МетаданныеКонтента["filename"];
			Если Не ИмяФайла = Неопределено Тогда
				ИмяФайла = ИмяФайла["filename"];
			КонецЕсли;

		Иначе

			МетаданныеКонтента = ЗначениеЗаголовка(Строка.Метаданные, "Content-Disposition");
			
			Если МетаданныеКонтента = Неопределено Тогда
				Продолжить;
			КонецЕсли;

			Имя = МетаданныеКонтента["name"];
			ИмяФайла = МетаданныеКонтента["filename"];

		КонецЕсли;	

		Значение = Неопределено;

		Если ИмяФайла = Неопределено Тогда	

			Контейнер = Результат.Данные;

			Если Не Строка.Значение = Неопределено Тогда
				Значение = ПолучитьСтрокуИзДвоичныхДанных(Строка.Значение, КодировкаТекста.UTF8);
			КонецЕсли;

		Иначе

			Контейнер = Результат.Файлы;

			Заголовки = Строка.Метаданные["Заголовки"];
			Если Не Заголовки = Неопределено Тогда
				ТипКонтента = ЗначениеЗаголовка(Заголовки, "Content-Type");
			Иначе
				ТипКонтента = Неопределено;
			КонецЕсли;
	
			Если Не Строка.Значение = Неопределено Тогда
				ТипКонтента = ?(ТипКонтента = Неопределено, "application/octet-stream", ТипКонтента);
				Значение = ТекстовоеПредставлениеДвоичныхДанных(Строка.Значение, ТипКонтента);
			КонецЕсли;

		КонецЕсли;

		НайденноеЗначение = Контейнер[Имя];
		Если НайденноеЗначение = Неопределено Тогда
			Контейнер.Вставить(Имя, Значение);
		ИначеЕсли ТипЗнч(НайденноеЗначение) = Тип("Массив") Тогда
			НайденноеЗначение.Добавить(Значение);
		Иначе
			МассивЗначений = Новый Массив();
			МассивЗначений.Добавить(НайденноеЗначение);
			МассивЗначений.Добавить(Значение);
			Контейнер.Вставить(Имя, МассивЗначений);
		КонецЕсли;	

	КонецЦикла;

	Возврат Результат;
	
КонецФункции

// Преобразует двоичные данные в текстовое представление.
// Для бинарных данных возвращает Data URL (base64).
// Для текстовых данных возвращает UTF-8 строку.
//
// Параметры:
//   ДвоичныеДанные - ДвоичныеДанные - Данные для преобразования
//   ТипКонтента    - Строка - MIME-тип данных
//
// Возвращаемое значение:
//   Строка
//
Функция ТекстовоеПредставлениеДвоичныхДанных(ДвоичныеДанные, ТипКонтента)

	Если ДвоичныеДанныеСодержатУправляющиеСимволы(ДвоичныеДанные) Тогда

		Возврат СтрШаблон("data:%1;base64,%2", ТипКонтента, Base64Строка(ДвоичныеДанные));
	
	Иначе
		
		Возврат ПолучитьСтрокуИзДвоичныхДанных(ДвоичныеДанные, КодировкаТекста.UTF8);

	КонецЕсли;
	
КонецФункции

// Проверяет, содержат ли двоичные данные управляющие символы (бинарные данные).
// Анализирует первые 1024 байта для определения типа содержимого.
//
// Параметры:
//   ДвоичныеДанные - ДвоичныеДанные - Данные для проверки
//
// Возвращаемое значение:
//   Булево - Истина, если данные содержат управляющие символы (бинарные)
//
Функция ДвоичныеДанныеСодержатУправляющиеСимволы(ДвоичныеДанные)

	КоличествоЧитаемыхБайтов = 1024;

	NUL = 0;
	BS = 8;
	CR = 13;
	SUB = 26;

	ЧтениеДанных = Новый ЧтениеДанных(ДвоичныеДанные);
	
	СчетчикБайтов = 0;
	Пока Истина Цикл

		Если ЧтениеДанных.ЧтениеЗавершено Или СчетчикБайтов = КоличествоЧитаемыхБайтов Тогда
			Прервать;
		КонецЕсли;

		Байт = ЧтениеДанных.ПрочитатьБайт();

		Если Байт > NUL И Байт < BS Или Байт > CR И Байт < SUB Тогда
			Возврат Истина;
		КонецЕсли;

		СчетчикБайтов = СчетчикБайтов + 1;

	КонецЦикла;

	Возврат Ложь;

КонецФункции

// Нормализует заголовки для сериализации в JSON.
// Для нативного веб-сервера преобразует СтроковыеЗначения в простые строки.
//
// Параметры:
//   Заголовки - Соответствие, СловарьЗаголовков - Коллекция заголовков
//
// Возвращаемое значение:
//   Соответствие - Нормализованные заголовки для JSON
//
Функция ЗаголовкиДляJson(Заголовки)
	
	Если ЭтоНативныйВебСервер Тогда

		НовыеЗаголовки = Новый Соответствие();

		Для Каждого КлючИЗначение Из Заголовки Цикл

			Значение = Заголовки[КлючИЗначение.Ключ];

			Если ТипЗнч(Значение) = Тип("СтроковыеЗначения") Тогда
				НовыеЗаголовки[КлючИЗначение.Ключ] = Значение[0];
			Иначе
				НовыеЗаголовки[КлючИЗначение.Ключ] = Значение;
			КонецЕсли;

		КонецЦикла;

		Возврат НовыеЗаголовки;

	Иначе

		Возврат Заголовки;

	КонецЕсли;

КонецФункции

// Сериализует данные в JSON с форматированием.
//
// Параметры:
//   Данные - Соответствие, Структура - Данные для сериализации
//
// Возвращаемое значение:
//   Строка
//
Функция ВJson(Данные)
		
	ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто, "    ");

	ЗаписьJSON = Новый ЗаписьJSON();
	ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON);
	ЗаписатьJSON(ЗаписьJSON, Данные);

	Возврат ЗаписьJSON.Закрыть();

КонецФункции

// Создаёт новую структуру с указанными ключами из исходной структуры.
// Копирует только запрошенные поля. Значения null заменяются на пустые строки.
//
// Параметры:
//   ИсходнаяСтруктура - Структура - Структура-источник данных
//   КопируемыеКлючи   - Строка - Имена копируемых полей через запятую
//
// Возвращаемое значение:
//   Структура - Новая структура с запрошенными полями
//
Функция СкопироватьСтруктуру(ИсходнаяСтруктура, КопируемыеКлючи)

	Результат = Новый Структура(КопируемыеКлючи);
	ЗаполнитьЗначенияСвойств(Результат, ИсходнаяСтруктура);

	Для Каждого КлючИЗначение Из Результат Цикл
		Если Результат[КлючИЗначение.Ключ] = NULL Тогда
			Результат[КлючИЗначение.Ключ] = "";
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;
	
КонецФункции

Процедура ЗаполнитьПоддерживаемыеМедиаТипы()

	ПоддерживаемыеМедиаТипы = Новый Массив();
	ПоддерживаемыеМедиаТипы.Добавить("image/webp");
	ПоддерживаемыеМедиаТипы.Добавить("image/svg+xml");
	ПоддерживаемыеМедиаТипы.Добавить("image/jpeg");
	ПоддерживаемыеМедиаТипы.Добавить("image/png");
	ПоддерживаемыеМедиаТипы.Добавить("image/*");

КонецПроцедуры

#КонецОбласти