// BSLLS:ExportVariables-off

#Использовать 1connector

Перем ТекстRobots Экспорт; // Строка
Перем ASCII_Deny Экспорт; // Строка
Перем ASCII_Teapot; // Строка
Перем АдресРедиректа; // Строка
Перем ПоддерживаемыеМедиаТипы; // Массив из Строка

Перем НастройкиВебСервера; // Ссылка на объект Настройки (winow)
Перем Парсеры; // Ссылка на объект Парсеры (winow)
Перем ЭтоНативныйВебСервер; // Булево

#Область ПрограммныйИнтерфейс

// Заполняет ответ json данными
//
// Параметры:
//   Ответ - winow.Ответ - Ответ
//   Данные - Соответствие, Структура - Данные для передачи в тело ответа
//   АлгоритмСжатия - Строка - Алгоритм сжатия данных (gzip, deflate, brotli, zstd)
Процедура ЗаполнитьОтветJson(Ответ, Данные, АлгоритмСжатия = Неопределено) Экспорт

	Ответ.УстановитьТипКонтента("json");
	
	ТекстJson = ВJson(Данные);
	
	Если АлгоритмСжатия = "gzip" Тогда

		Компрессор = Новый GZipКомпрессор();
		Ответ.Заголовки["Content-Encoding"] = "gzip";
		Ответ.ТелоДвоичныеДанные = Компрессор.Упаковать(ПолучитьДвоичныеДанныеИзСтроки(ТекстJson));

	ИначеЕсли АлгоритмСжатия = "deflate" Тогда

		Компрессор = Новый DeflateКомпрессор();
		Ответ.Заголовки["Content-Encoding"] = "deflate";
		Ответ.ТелоДвоичныеДанные = Компрессор.Упаковать(ПолучитьДвоичныеДанныеИзСтроки(ТекстJson));

	ИначеЕсли АлгоритмСжатия = "brotli" Тогда

		Компрессор = Новый BrotliКомпрессор();
		Ответ.Заголовки["Content-Encoding"] = "br";
		Ответ.ТелоДвоичныеДанные = Компрессор.Упаковать(ПолучитьДвоичныеДанныеИзСтроки(ТекстJson));

	ИначеЕсли АлгоритмСжатия = "zstd" Тогда

		Компрессор = Новый ZStdКомпрессор();
		Ответ.Заголовки["Content-Encoding"] = "zstd";
		Ответ.ТелоДвоичныеДанные = Компрессор.Упаковать(ПолучитьДвоичныеДанныеИзСтроки(ТекстJson));

	Иначе

		Ответ.ТелоТекст = ТекстJson;

	КонецЕсли;

КонецПроцедуры

// Заполняет ответ по состоянию
//
// Параметры:
//   Ответ - winow.Ответ - Ответ
//   КодСостояния - Число - Код состояния HTTP
Процедура ЗаполнитьОтветПоСостоянию(Ответ, КодСостояния) Экспорт
	
	Ответ.УстановитьСостояние(КодСостояния);

	Если КодСостояния >= КодыСостоянияHTTP.ПеремещеноНавсегда_301 
		И КодСостояния <= КодыСостоянияHTTP.ВременноеПеренаправление_307
		И Не КодСостояния = КодыСостоянияHTTP.НеИзменялось_304 Тогда

		Ответ.Заголовки["Location"] = АдресРедиректа;

	ИначеЕсли КодСостояния = КодыСостоянияHTTP.НеАвторизован_401 Тогда

		Ответ.Заголовки["WWW-Authenticate"] = "Basic realm=""Fake Realm""";

	ИначеЕсли КодСостояния = КодыСостоянияHTTP.НеобходимаОплата_402 Тогда

		Ответ.ТелоТекст = "Fuck you, pay me!";
		Ответ.Заголовки["x-more-info"] = "http://vimeo.com/22053820";

	ИначеЕсли КодСостояния = КодыСостоянияHTTP.Неприемлемо_406 Тогда

		Данные = Новый Структура();
		Данные.Вставить("message", "Client did not request a supported media type.");
		Данные.Вставить("accept", ПоддерживаемыеМедиаТипы);

		ЗаполнитьОтветJson(Ответ, Данные);

	ИначеЕсли КодСостояния = КодыСостоянияHTTP.НеобходимаАутентификацияПрокси_407 Тогда

		Ответ.Заголовки["Proxy-Authenticate"] = "Basic realm=""Fake Realm""";

	ИначеЕсли КодСостояния = 418 Тогда

		Ответ.ТелоТекст = ASCII_Teapot;
		Ответ.СостояниеТекст = "I'm a teapot";
		Ответ.Заголовки["x-more-info"] = "http://tools.ietf.org/html/rfc2324";
		Ответ.Заголовки.Удалить("Content-Type");

	КонецЕсли;

КонецПроцедуры

// Данные входящего запроса
//
// Параметры:
//   Ключи - Строка - Ключи через запятую
//   Запрос - winow.ВходящийЗапрос - Входящий запрос
//   ДанныеФормы - winow.ДанныеСоставнойФормы - Данные составной формы (multipart)
//
// Возвращаемое значение:
//   Структура
Функция ПолучитьДанныеЗапроса(Ключи, Запрос, ДанныеФормы = Неопределено) Экспорт
	
	ДанныеФормы = РазделитьДанныеФормы(ДанныеФормы);
	ТелоЗапросОбъект = Запрос.ТелоЗапросОбъект();
	Данные = "";

	ТипКонтента = НРег(ЗначениеЗаголовка(Запрос.Заголовки, "Content-Type"));
	Если СтрНайти(ТипКонтента, "application/x-www-form-urlencoded") Тогда
		ДанныеФормы.Данные = Парсеры.ПараметрыИзТекста(Запрос.Тело);
	ИначеЕсли Не ЗначениеЗаполнено(ДанныеФормы.Данные) И Не ЗначениеЗаполнено(ДанныеФормы.Файлы) Тогда
		Данные = Запрос.Тело;
	КонецЕсли;

	ДанныеЗапроса = Новый Структура();
	ДанныеЗапроса.Вставить("url", ПолучитьURL(Запрос.ПолныйПуть));
	ДанныеЗапроса.Вставить("method", Запрос.Метод);
	ДанныеЗапроса.Вставить("args", Запрос.ПараметрыИменные);
	ДанныеЗапроса.Вставить("headers", ЗаголовкиДляJson(Запрос.Заголовки));
	ДанныеЗапроса.Вставить("origin", IPАдресУдаленногоУзла(Запрос));
	ДанныеЗапроса.Вставить("json", ?(Не ТелоЗапросОбъект = Неопределено, ТелоЗапросОбъект, null));
	ДанныеЗапроса.Вставить("data", Данные);
	ДанныеЗапроса.Вставить("form", ДанныеФормы.Данные);
	ДанныеЗапроса.Вставить("files", ДанныеФормы.Файлы);
	ДанныеЗапроса.Вставить("gzipped", Истина);
	ДанныеЗапроса.Вставить("deflated", Истина);
	ДанныеЗапроса.Вставить("brotli", Истина);
	ДанныеЗапроса.Вставить("zstd", Истина);

	Результат = СкопироватьСтруктуру(ДанныеЗапроса, Ключи);

	Возврат Результат;

КонецФункции

// Данные аутентификации из входящего запроса
//
// Параметры:
//   Запрос - winow.ВходящийЗапрос - Входящий запрос
//
// Возвращаемое значение:
//   Структура:
//     Общее:
//       * Тип - Строка - Тип аутентификации (basic, bearer)
//     Basic:
//       * ИмяПользователя - Строка, Неопределено - Имя пользователя
//       * Пароль - Строка, Неопределено - Пароль
//     Bearer:
//       * Токен - Строка - Токен
Функция ДанныеАутентификации(Запрос) Экспорт

	Данные = Новый Структура("Тип", "");

	Заголовок = ЗначениеЗаголовка(Запрос.Заголовки, "Authorization");
	Если ПустаяСтрока(Заголовок) Тогда
		Возврат Данные;
	КонецЕсли;

	РазделеннаяСтрока = РазделитьСтроку(Заголовок, " ");

	ТипАутентификации = НРег(РазделеннаяСтрока.Лево);
	Данные.Тип = ТипАутентификации;

	Значение = РазделеннаяСтрока.Право;

	Если ТипАутентификации = "basic" Тогда

		Данные.Вставить("ИмяПользователя");
		Данные.Вставить("Пароль");

		Попытка
			ПользовательИПароль = ПолучитьСтрокуИзДвоичныхДанных(Base64Значение(Значение));
			ПользовательИПароль = РазделитьСтроку(ПользовательИПароль, ":");
			
			Данные.ИмяПользователя = ПользовательИПароль.Лево;
			Данные.Пароль = ПользовательИПароль.Право;	
		Исключение	
			Данные.ИмяПользователя = Неопределено;
			Данные.Пароль = Неопределено;			
		КонецПопытки;

	ИначеЕсли ТипАутентификации = "bearer" Тогда

		Данные.Вставить("Токен", Значение);

	КонецЕсли;

	Возврат Данные;

КонецФункции

// Значение заголовка по имени
//
// Параметры:
//   Заголовки - Соответствие, СловарьЗаголовков - Коллекция заголовков
//   Имя - Строка - Имя заголовка
//
// Возвращаемое значение:
//   Строка, Неопределено
Функция ЗначениеЗаголовка(Заголовки, Знач Имя) Экспорт

	Имя = НРег(Имя);

	Для Каждого Заголовок Из Заголовки Цикл
		Если НРег(Заголовок.Ключ) = Имя Тогда
			Если ТипЗнч(Заголовок.Значение) = Тип("Строка") 
				Или ТипЗнч(Заголовок.Значение) = Тип("Соответствие") Тогда
				Возврат Заголовок.Значение;
			ИначеЕсли Заголовок.Значение.Количество() Тогда
				Возврат Заголовок.Значение[0];
			Иначе
				Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

КонецФункции

// Парсит многозначный заголовок
//
// Параметры:
//   Значение - Строка - Значение заголовка
//
// Возвращаемое значение:
//   Массив из Строка - Массив значений
Функция РаспаристьМногозначныйЗаголовок(Значение) Экспорт
	
	Результат = Новый Массив();

	РегулярноеВыражение = Новый РегулярноеВыражение("\s*(W\/)?\""?([^""]*)\""?\s*");
	Подстроки = СтрРазделить(Значение, ",");

	Для Каждого Подстрока Из Подстроки Цикл
		КоллекцияСовпадений = РегулярноеВыражение.НайтиСовпадения(Подстрока);

		Для Каждого Совпадение Из КоллекцияСовпадений Цикл
			НайденноеЗначение = Совпадение.Группы[2].Значение;
			Если ЗначениеЗаполнено(НайденноеЗначение) Тогда
				Результат.Добавить(НайденноеЗначение);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

	Возврат Результат;

КонецФункции

// Получает URL к запущенному веб-серверу с добавлением пути
//
// Параметры:
//   ПолныйПуть - Строка - Путь после порта веб-сервера, включая "/"
//
// Возвращаемое значение:
//   Строка - URL
Функция ПолучитьURL(ПолныйПуть) Экспорт

	Возврат "http://" 
		+ НастройкиВебСервера.ИмяХоста 
		+ ?(НастройкиВебСервера.Порт = 80, "", ":" + Формат(НастройкиВебСервера.Порт, "ЧГ="))
		+ ПолныйПуть;

КонецФункции

// Преобразует универсальную дату в дату формата rfc1123-date.
// См. https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html, п. 3.3.1.
//
// Параметры:
//   Дата - Дата, Неопределено - Если не указано, то беретеся текущая универсальная дата
//
// Возвращаемое значение:
//   Строка
Функция ДатаHTTP(Знач Дата = Неопределено) Экспорт

	Если Дата = Неопределено Тогда
		Дата = ТекущаяУниверсальнаяДата();
	КонецЕсли;

	Возврат Формат(Дата, "Л=en; ДФ='ддд, дд МММ гггг ЧЧ:мм:сс ''GMT'''");

КонецФункции

// Получает число из строки
//
// Параметры:
//   Значение - Строка - Число строкой
//
// Возвращаемое значение:
//   Число
Функция ВЧисло(Значение) Экспорт
	Возврат Новый ОписаниеТипов("Число").ПривестиЗначение(Значение);
КонецФункции

// Дополняет соответствие
//
// Параметры:
//   Приемник - Соответствие - Приемник
//   Источник - Соответствие - Источник
Процедура ДополнитьСоответствие(Приемник, Источник) Экспорт

	Для Каждого Элемент Из Источник Цикл
		Приемник.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Выбирает случайный элемент с учетом веса
//
// Параметры:
//   Список - Массив из Структура - Взвешенный список:
//     * Значение - Произвольный - Значение
//     * Вес - Число - Вес
//
// Возвращаемое значение:
//   Произвольный - Случайное значение из списка
Функция ВыбратьСлучайныйЭлементСУчетомВеса(Список) Экспорт
	
	ОбщийВес = 0;
	НакопленныеВеса = Новый Массив();
	Для Каждого Элемент Из Список Цикл
		ОбщийВес = ОбщийВес + Элемент.Вес;
		НакопленныеВеса.Добавить(ОбщийВес);
	КонецЦикла;

	ГСЧ = Новый ГенераторСлучайныхЧисел();
	СлучайноеЧисло = ГСЧ.СлучайноеЧисло(0, ОбщийВес);

	НижняяГраница = 0;
	ВерхняяГраница = Список.Количество();
	Пока НижняяГраница < ВерхняяГраница Цикл
		Середина = Цел((НижняяГраница + ВерхняяГраница) / 2);
		Если СлучайноеЧисло < НакопленныеВеса[Середина] Тогда
			ВерхняяГраница = Середина;
		Иначе
			НижняяГраница = Середина + 1;
		КонецЕсли;
	КонецЦикла;

	Возврат Список[НижняяГраница].Значение;

КонецФункции

// Разделяет строку по разделителю
//
// Параметры:
//   Строка - Строка
//   Разделитель - Строка
//
// Возвращаемое значение:
//   Структура:
//     * Лево - Строка
//     * Право - Строка
Функция РазделитьСтроку(Строка, Разделитель) Экспорт

	Результат = Новый Структура("Лево, Право", "", "");
	ПозицияРазделителя = СтрНайти(Строка, Разделитель);

	Если ПозицияРазделителя = 0 Тогда
		Результат.Лево = Строка;
	Иначе
		Результат.Лево = Лев(Строка, ПозицияРазделителя - 1);
		Результат.Право = Сред(Строка, ПозицияРазделителя + СтрДлина(Разделитель));
	КонецЕсли;

	Возврат Результат;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

&Желудь
Процедура ПриСозданииОбъекта(
	&Пластилин("Настройки") Настройки,
	&Пластилин("Парсеры") _Парсеры,
	&Пластилин("ВебСервер") _ВебСервер)

	НастройкиВебСервера = Настройки;
	Парсеры = _Парсеры;
	ЭтоНативныйВебСервер = ТипЗнч(_ВебСервер) = Тип("НативныйВебСервер");
	
	ЗаполнитьПоддерживаемыеМедиаТипы();
	АдресРедиректа = "/redirect/1";
	
	ТекстRobots = "User-agent: *
	|Disallow: /deny";
	
	ASCII_Deny = "
	|          .-''''''-.
	|        .' _      _ '.
	|       /   O      O   \
	|      :                :
	|      |                |
	|      :       __       :
	|       \  .-""`  `""-.  /
	|        '.          .'
	|          '-......-'
	|     YOU SHOULDN'T BE HERE";

	ASCII_Teapot = "
	|    -=[ teapot ]=-
	|
	|       _...._
	|     .'  _ _ `.
	|    | .""` ^ `"". _,
	|    \_;`""---""`|//
	|      |       ;/
	|      \_     _/
	|        `""""""`";

КонецПроцедуры

Функция IPАдресУдаленногоУзла(Запрос)

	Адрес = ЗначениеЗаголовка(Запрос.Заголовки, "X-Forwarded-For");
	Если Не ЗначениеЗаполнено(Адрес) Тогда
		Адрес = Запрос.АдресУдаленногоУзла;
	КонецЕсли;

	Подстрока = "::ffff:"; // BSLLS:UsingHardcodeNetworkAddress-off
	Если СтрНачинаетсяС(Адрес, Подстрока) Тогда
		Адрес = Сред(Адрес, СтрДлина(Подстрока) + 1);
	КонецЕсли;

	Возврат Адрес;

КонецФункции

Функция РазделитьДанныеФормы(ДанныеФормы)

	Результат = Новый Структура();
	Результат.Вставить("Данные", Новый Соответствие());
	Результат.Вставить("Файлы", Новый Соответствие());

	Если ДанныеФормы = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;

	Для Индекс = 0 По ДанныеФормы.Количество() - 1 Цикл

		Строка = ДанныеФормы.ПолучитьПоИндексу(Индекс);

		Если ЭтоНативныйВебСервер Тогда

			МетаданныеКонтента = Строка.Метаданные;
			
			Имя = МетаданныеКонтента["name"];
			Если Не Имя = Неопределено Тогда
				Имя = Имя["name"];
			КонецЕсли;

			ИмяФайла = МетаданныеКонтента["filename"];
			Если Не ИмяФайла = Неопределено Тогда
				ИмяФайла = ИмяФайла["filename"];
			КонецЕсли;

		Иначе

			МетаданныеКонтента = ЗначениеЗаголовка(Строка.Метаданные, "Content-Disposition");
			
			Если МетаданныеКонтента = Неопределено Тогда
				Продолжить;
			КонецЕсли;

			Имя = МетаданныеКонтента["name"];
			ИмяФайла = МетаданныеКонтента["filename"];

		КонецЕсли;	

		Значение = Неопределено;

		Если ИмяФайла = Неопределено Тогда	

			Контейнер = Результат.Данные;

			Если Не Строка.Значение = Неопределено Тогда
				Значение = ПолучитьСтрокуИзДвоичныхДанных(Строка.Значение, КодировкаТекста.UTF8);
			КонецЕсли;

		Иначе

			Контейнер = Результат.Файлы;

			Заголовки = Строка.Метаданные["Заголовки"];
			Если Не Заголовки = Неопределено Тогда
				ТипКонтента = ЗначениеЗаголовка(Заголовки, "Content-Type");
			Иначе
				ТипКонтента = Неопределено;
			КонецЕсли;
	
			Если Не Строка.Значение = Неопределено Тогда
				ТипКонтента = ?(ТипКонтента = Неопределено, "application/octet-stream", ТипКонтента);
				Значение = ТекстовоеПредставлениеДвоичныхДанных(Строка.Значение, ТипКонтента);
			КонецЕсли;

		КонецЕсли;

		НайденноеЗначение = Контейнер[Имя];
		Если НайденноеЗначение = Неопределено Тогда
			Контейнер.Вставить(Имя, Значение);
		ИначеЕсли ТипЗнч(НайденноеЗначение) = Тип("Массив") Тогда
			НайденноеЗначение.Добавить(Значение);
		Иначе
			МассивЗначений = Новый Массив();
			МассивЗначений.Добавить(НайденноеЗначение);
			МассивЗначений.Добавить(Значение);
			Контейнер.Вставить(Имя, МассивЗначений);
		КонецЕсли;	

	КонецЦикла;

	Возврат Результат;
	
КонецФункции

Функция ТекстовоеПредставлениеДвоичныхДанных(ДвоичныеДанные, ТипКонтента)

	Если ДвоичныеДанныеСодержатУправляющиеСимволы(ДвоичныеДанные) Тогда

		Возврат СтрШаблон("data:%1;base64,%2", ТипКонтента, Base64Строка(ДвоичныеДанные));
	
	Иначе
		
		Возврат ПолучитьСтрокуИзДвоичныхДанных(ДвоичныеДанные, КодировкаТекста.UTF8);

	КонецЕсли;
	
КонецФункции

Функция ДвоичныеДанныеСодержатУправляющиеСимволы(ДвоичныеДанные)

	КоличествоЧитаемыхБайтов = 1024;

	NUL = 0;
	BS = 8;
	CR = 13;
	SUB = 26;

	ЧтениеДанных = Новый ЧтениеДанных(ДвоичныеДанные);
	
	СчетчикБайтов = 0;
	Пока Истина Цикл

		Если ЧтениеДанных.ЧтениеЗавершено Или СчетчикБайтов = КоличествоЧитаемыхБайтов Тогда
			Прервать;
		КонецЕсли;

		Байт = ЧтениеДанных.ПрочитатьБайт();

		Если Байт > NUL И Байт < BS Или Байт > CR И Байт < SUB Тогда
			Возврат Истина;
		КонецЕсли;

		СчетчикБайтов = СчетчикБайтов + 1;

	КонецЦикла;

	Возврат Ложь;

КонецФункции

Функция ЗаголовкиДляJson(Заголовки)
	
	Если ЭтоНативныйВебСервер Тогда

		НовыеЗаголовки = Новый Соответствие();

		Для Каждого КлючИЗначение Из Заголовки Цикл

			Значение = Заголовки[КлючИЗначение.Ключ];

			Если ТипЗнч(Значение) = Тип("СтроковыеЗначения") Тогда
				НовыеЗаголовки[КлючИЗначение.Ключ] = Значение[0];
			Иначе
				НовыеЗаголовки[КлючИЗначение.Ключ] = Значение;
			КонецЕсли;

		КонецЦикла;

		Возврат НовыеЗаголовки;

	Иначе

		Возврат Заголовки;

	КонецЕсли;

КонецФункции

Функция ВJson(Данные)
		
	ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто, "    ");

	ЗаписьJSON = Новый ЗаписьJSON();
	ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON);
	ЗаписатьJSON(ЗаписьJSON, Данные);

	Возврат ЗаписьJSON.Закрыть();

КонецФункции

Функция СкопироватьСтруктуру(ИсходнаяСтруктура, КопируемыеКлючи)

	Результат = Новый Структура(КопируемыеКлючи);
	ЗаполнитьЗначенияСвойств(Результат, ИсходнаяСтруктура);

	Для Каждого КлючИЗначение Из Результат Цикл
		Если Результат[КлючИЗначение.Ключ] = NULL Тогда
			Результат[КлючИЗначение.Ключ] = "";
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;
	
КонецФункции

Процедура ЗаполнитьПоддерживаемыеМедиаТипы()

	ПоддерживаемыеМедиаТипы = Новый Массив();
	ПоддерживаемыеМедиаТипы.Добавить("image/webp");
	ПоддерживаемыеМедиаТипы.Добавить("image/svg+xml");
	ПоддерживаемыеМедиаТипы.Добавить("image/jpeg");
	ПоддерживаемыеМедиаТипы.Добавить("image/png");
	ПоддерживаемыеМедиаТипы.Добавить("image/*");

КонецПроцедуры

#КонецОбласти